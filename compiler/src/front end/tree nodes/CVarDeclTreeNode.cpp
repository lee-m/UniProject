//------------------------------------------------------------------------------------------
// File: CVarDeclTreeNode.cpp
// Desc: Variable declaration within the parse tree
// Auth: Lee Millward
//------------------------------------------------------------------------------------------

#include "StdHeader.h"
#include "CVarDeclTreeNode.h"
#include "CLiteralTreeNode.h"
#include "CIdentifierTreeNode.h"
#include "CUnaryExprTreeNode.h"
#include "CSymbolTable.h"
#include "CGlobalDataStore.h"
#include "CLiteralRefTreeNode.h"

//-------------------------------------------------------------
CVarDeclTreeNode::CVarDeclTreeNode(void)
{
	InitExpression = NULL;
	VarId = NULL;

	IsConst = false;
	Spilled = false;
	GlobalVar = false;

	AllocatedReg = REG_NONE;
	StackFrameAddr = 0;
	SpillPoint = 0;
	DeclPoint;
}
//-------------------------------------------------------------

//-------------------------------------------------------------
void CVarDeclTreeNode::DumpAsParseTreeNode(TiXmlElement *XmlNode)
{
	TiXmlElement *VarDeclNode;
	VarDeclNode = XmlNode->InsertEndChild(TiXmlElement("var_decl"))->ToElement();

	//add the const attribute
	TiXmlElement *ConstNode;
	ConstNode = VarDeclNode->InsertEndChild(TiXmlElement("is_const"))->ToElement();

	if(IsConst)
		ConstNode->InsertEndChild(TiXmlText("true"));
	else
		ConstNode->InsertEndChild(TiXmlText("false"));

	//add the type
	TiXmlElement *TypeNode;
	TypeNode = VarDeclNode->InsertEndChild(TiXmlElement("type"))->ToElement();
	TypeNode->InsertEndChild(TiXmlText(CUtilFuncs::TokenTypeToStr(VarType).c_str()));

	//add the initialisation expression (if any)
	if(InitExpression)
	{
		TiXmlElement *InitNode;
		InitNode = VarDeclNode->InsertEndChild(TiXmlElement("initialiser"))->ToElement();
		InitExpression->DumpAsParseTreeNode(InitNode);
	}

	VarId->DumpAsParseTreeNode(VarDeclNode);
}
//-------------------------------------------------------------

//-------------------------------------------------------------
void CVarDeclTreeNode::DumpAsMIRTreeNode(ofstream &OutFile)
{
	if(IsConst)
		OutFile << "const ";

	//type and name
	OutFile << CUtilFuncs::TokenTypeToStr(VarType) << " ";
	VarId->DumpAsMIRTreeNode(OutFile);

	//initialisation expr
	if(InitExpression)
	{
		OutFile << " = ";
		InitExpression->DumpAsMIRTreeNode(OutFile);
	}
}
//-------------------------------------------------------------

//-------------------------------------------------------------
void CVarDeclTreeNode::DestroyNode(void)
{
	if(InitExpression)
	{
		InitExpression->DestroyNode();
		InitExpression = NULL;
	}

	VarId->DestroyNode();
	VarId = NULL;
	delete this;
}
//-------------------------------------------------------------

//-------------------------------------------------------------
CTreeNode* CVarDeclTreeNode::RewriteIntoMIRForm(CTreeNode *Stmts)
{
	//add a plain var decl without the init expression. We convert any boolean
	//type vars into integer types here also
	if(VarType == TOKTYPE_BOOLEANTYPE)
		VarType = TOKTYPE_INTEGERTYPE;

	CVarDeclTreeNode *NewVarDecl;
	NewVarDecl = (CVarDeclTreeNode*)CTreeNodeFactory::GetSingletonPtr()->BuildVarDecl(
										VarId->IdName, IsConst, VarType);

	//copy across the global attribute
	NewVarDecl->GlobalVar = GlobalVar;

	//add the new var decl to the symbol table
	CSymbolTable::GetSingletonPtr()->AddSymbol(VarId->IdName, NewVarDecl, 0, VarType);
	CTreeNodeFactory *TreeNodeFactory = CTreeNodeFactory::GetSingletonPtr();

	//convert the initialisation expression (if any)
	if(InitExpression)
	{
		//the assignment expression storing the value from the simplified init expr
		//into this variable
		CTreeNode *AssignExpr = NULL;

		switch(InitExpression->Code)
		{
		case TC_UNARY_EXPR:
				return SimplifyUnaryInitExpr(NewVarDecl, InitExpression, Stmts);

		case TC_BOOLEAN_EXPR:
			return SimplifyBooleanInitExpr(InitExpression, Stmts, NewVarDecl);

		case TC_ARITH_EXPR:
			{
				//the last statement generated by the simplification of the intialisation
				//expression is the one which computes the value to store in this variable,
				//so we generate a new assignment expression from that (temporary)
				//variable into this one
				CTreeNode *ValExpr = InitExpression->RewriteIntoMIRForm(Stmts);

				//create the assignment expression from ValExpr into this variable
				AssignExpr = TreeNodeFactory->BuildAssignmentExpr(
					VarId->CreateCopy(), ValExpr);

				break;
			}

		case TC_LITERAL:
			{
				AssignExpr = SimplifyLiteralInitExpr(InitExpression, Stmts);
				break;
			}

		case TC_ARRAY_REF:
			{
				CTreeNode *Temp = InitExpression->RewriteIntoMIRForm(Stmts);
				AssignExpr = TreeNodeFactory->BuildAssignmentExpr(VarId->CreateCopy(), Temp);
				break;
			}

		case TC_CALLEXPR:
			{
				AssignExpr = SimplifyCallExprInitExpr(InitExpression, Stmts, VarType);
				break;
			}

		case TC_IDENTIFIER:
			{
				//simply generate an assignment from the identifier to the var
				AssignExpr = TreeNodeFactory->BuildAssignmentExpr(
					NewVarDecl->VarId->CreateCopy(), InitExpression->CreateCopy());
				break;
			}

		default:
			InternalError("unknown var decl init expression type");
		}

		Stmts->AddChild(NewVarDecl);
		return AssignExpr;
	}

	return NewVarDecl;
}
//-------------------------------------------------------------

//-------------------------------------------------------------
CTreeNode* CVarDeclTreeNode::CreateCopy(void)
{
	//create the new var_decl node
	CVarDeclTreeNode *NewVarDecl;
	NewVarDecl = (CVarDeclTreeNode*)CTreeNodeFactory::GetSingletonPtr()->BuildVarDecl(
		VarId->IdName, IsConst, VarType);

	NewVarDecl->GlobalVar = GlobalVar;
	return NewVarDecl;
}
//-------------------------------------------------------------

//-------------------------------------------------------------
CTreeNode* CVarDeclTreeNode::SimplifyUnaryInitExpr(CVarDeclTreeNode *NewVarDecl, 
																									 CTreeNode *InitExpr,
																									 CTreeNode *Stmts)
{
	CTreeNodeFactory *TreeNodeFactory = CTreeNodeFactory::GetSingletonPtr();

	//simplify the expression being negated
	CTreeNode *Expr;
	CTreeNode *AssignExpr = NULL;

	Expr = InitExpr->GetChild(UNARY_EXPR_EXPR)->RewriteIntoMIRForm(Stmts);

	//assign the value of the simplified expression without the operator
	//being applied to the variable
	AssignExpr = TreeNodeFactory->BuildAssignmentExpr(
		NewVarDecl->VarId->CreateCopy(), Expr);

	//add the var decl, followed by the assignment expression
	Stmts->AddChild(NewVarDecl);
	Stmts->AddChild(AssignExpr);

	//generate a new unary expression, using the variable which
	//is going to store the new value as the operand since this already
	//contains the value to be negated/flipped
	Expr = TreeNodeFactory->BuildUnaryExpression(NewVarDecl->VarId->CreateCopy(),
		((CUnaryExprTreeNode*)InitExpression)->Operator);

	//assign the new unary expr back into the variable
	AssignExpr = TreeNodeFactory->BuildAssignmentExpr(
		NewVarDecl->VarId->CreateCopy(), Expr);

	//all done
	return AssignExpr;
}
//-------------------------------------------------------------

//-------------------------------------------------------------
CTreeNode* CVarDeclTreeNode::SimplifyLiteralInitExpr(CTreeNode *InitExpr,
																										 CTreeNode *Stmts)
{
	CTreeNode *TempRhs = NULL;

	//save on typing later on
	CGlobalDataStore *GlobalStore = CGlobalDataStore::GetSingletonPtr(); 
	CTreeNodeFactory *TreeNodeFactory = CTreeNodeFactory::GetSingletonPtr();

	//we need to check for string literals here so we can replace
	//uses of them with a unique reference number
	if(((CLiteralTreeNode*)InitExpr)->LitType == TOKTYPE_STRINGLITERAL)
	{
		CLiteralTreeNode *StrLit = (CLiteralTreeNode*)InitExpression;
		CLiteralRefTreeNode *StrRef;

		//build a new ref for this lit if we need one
		StrRef = (CLiteralRefTreeNode*)TreeNodeFactory->BuildLiteralRef(StrLit,
			GlobalStore->GetStrLitRefNo(StrLit->LitValue));

		//add it
		GlobalStore->AddLiteral(StrLit->LitValue, StrRef->RefID, LT_STRING);
		TempRhs = StrRef;
	}
	else
	{
		//simply generate an assignment from the literal to the var
		TempRhs = InitExpression->RewriteIntoMIRForm(Stmts);
	}
	
	return TreeNodeFactory->BuildAssignmentExpr(
			VarId->CreateCopy(), TempRhs);
}
//-------------------------------------------------------------

//-------------------------------------------------------------
CTreeNode* CVarDeclTreeNode::SimplifyCallExprInitExpr(CTreeNode *InitExpr,
																											CTreeNode *Stmts,
																											TokenType VarType)
{
	//create a new temporary variable to store the result of the func call
	CVarDeclTreeNode *TempVar;
	CTreeNode *AssignExpr;
	CTreeNodeFactory *TreeNodeFactory = CTreeNodeFactory::GetSingletonPtr();

	TempVar = (CVarDeclTreeNode*)TreeNodeFactory->BuildVarDecl(
								CUtilFuncs::GenCompilerTempName(), false, VarType);

	//simplify the call_expr
	AssignExpr = TreeNodeFactory->BuildAssignmentExpr(
		TempVar->VarId->CreateCopy(), InitExpr->RewriteIntoMIRForm(Stmts));

	//add the temp var's symbol
	CSymbolTable::GetSingletonPtr()->AddSymbol(TempVar->VarId->IdName,
		TempVar, 0, VarType);

	//add the new temp var and it's initialisation to the
	//statement list
	Stmts->AddChild(TempVar);
	Stmts->AddChild(AssignExpr);

	//assign the return value from the function to this variable
	return TreeNodeFactory->BuildAssignmentExpr(
		VarId->CreateCopy(), TempVar->VarId->CreateCopy());
}
//-------------------------------------------------------------

//-------------------------------------------------------------
CTreeNode* CVarDeclTreeNode::SimplifyBooleanInitExpr(CTreeNode *InitExpr,
																										 CTreeNode *Stmts,
																										 CVarDeclTreeNode *NewVarDecl)
{
	CTreeNode *Expr = InitExpression->RewriteIntoMIRForm(Stmts);
	CTreeNodeFactory *TreeNodeFactory = CTreeNodeFactory::GetSingletonPtr();

	//simplifying a boolean expression can result in the generation of a
	//new boolean expr which gets returned to us. If this happens we only
	//want the LHS for the assign expr
	if(Expr->Code == TC_BOOLEAN_EXPR)
	{
		CTreeNode *Temp = Expr->GetChild(BLN_EXPR_LHS)->CreateCopy();
		Expr->DestroyNode();
		Expr = Temp;
	}

	//first, assign the LHS operand to our var
	CTreeNode *LhsAssign;
	LhsAssign = TreeNodeFactory->BuildAssignmentExpr(
		NewVarDecl->VarId->CreateCopy(), Expr);

	//add the new var and lhs assignment stmts
	Stmts->AddChild(NewVarDecl);
	return LhsAssign;
}
//-------------------------------------------------------------