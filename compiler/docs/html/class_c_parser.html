<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CP3343: CParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul></div>
<h1>CParser Class Reference</h1><!-- doxytag: class="CParser" --><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#f1b3d1f056e091028eee6915d8539349">CParser</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#a9e92d9d8b589f5e93aad4768293ae92">~CParser</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#f4ce3d1434b58134ec94e83795c204e7">ParseSourceFile</a> (const string &amp;InputFile)</td></tr>

<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#1cabdedd5fdc0c1d83168299c27a6b34">IsType</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#edf6b278729f314ba076cb8f4d6c556f">IsLiteral</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#f90fb427d9c479580276d7fe16d776ec">IsArithmeticOperator</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Tok)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#2dda8e89226ef7e1789514f6f4a9681d">IsBooleanOperator</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Tok)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#b25cc5a4c1ef9e899ef285aed7b13b75">IsLogicalOperator</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Tok)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#e58d729e2512194f87fa9b094039be8f">IsRelationalOperator</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Tok)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#69a461f8b9d2fe3a94cbadbb4f5e6de2">Error</a> (const string &amp;Msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#ec78655a12ee9572bfa80bbfc9e51175">Warning</a> (const string &amp;Msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#2643514486cbfbe676ad2e0c3b25e9a6">ExpectNextToken</a> (const string &amp;Msg, const <a class="el" href="struct_token__t.html">Token_t</a> &amp;Tok, <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> ExpType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#c8245a4a442b916cfa5b9aac0c7bfcc7">SkipToToken</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Tok)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#250d6b93735cc2ac277e2650e5a63e86">ParseVariableDeclaration</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#811433e48e5ff34bcded675ce04c112b">ParseArrayDeclaration</a> (<a class="el" href="class_c_var_decl_tree_node.html">CVarDeclTreeNode</a> *Var)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#c270f9076fe2be9d05648c69d214c1d6">ParseExpression</a> (<a class="el" href="_c_parser_8h.html#54471c9fe8cb8379414c338753808e45">ExprContext</a> Context)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#a94b49b91faf58991d443830f4e3a13c">ParseStatement</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#6bad239a9c86b8a6dd19d20fee25c160">ParseIfStatement</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#09c90fc1cd34875e97229b51516b682d">ParseAssignmentStatement</a> (const string &amp;IdentifierName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#3544ff599051d1611688a3b8939da09d">ParseWhileStatement</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#875dfb9fbc54fba3ebcb0cb4f3124f42">ParseFunctionDecl</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#1b6bf532d02d07e0378f0bcd9a1312e5">ParseReturnStatement</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#147afc14e002c04cfd48803e69325f12">ParseFunctionCall</a> (const string &amp;FuncName, bool RequireSemiColon)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#75b9f4903ac10249f0e213e3ade534dd">ParseFuncCallOrAssignmentExpr</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#909a4ef989d7cf778c83488798513973">ParseFuncDeclParameterList</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *ParmList, int &amp;NumParms)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#930a7ebfef02d003070100436055692e">ValidateFuncReturnsInfo</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> &amp;RetType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#f3916ded31c4943bb76d8b3bfa035e01">OperatorPrecedence</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Op)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#985862bbdf56b9c478b6ff03b74c9eeb">ReduceExpression</a> (stack&lt; <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> &gt; &amp;OpStack, stack&lt; <a class="el" href="class_c_tree_node.html">CTreeNode</a> * &gt; &amp;ValStack)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#a87085ab12a9675e5c860bcede9bd788">DestroyExpressionStack</a> (stack&lt; <a class="el" href="class_c_tree_node.html">CTreeNode</a> * &gt; &amp;ValStack)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#581f8643dc39a254f3bf01c4cc00e908">ParseExpressionTerm</a> (stack&lt; <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> &gt; &amp;OpStack, int &amp;ParenLevel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#08b89b3f4ad4fe059043453a7e39a4f1">TypeCheckExpression</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *Expr, <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> RequiredType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#60003db442f5bd0a8c2a060615a44035">TypeConvertsTo</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Orig, <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> To)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#ee457c7626a1f8c6f3b4ef7fa020529a">TypesCompatible</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> TypeOne, <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> TypeTwo)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#c208cea56aa2985ca1c3ba320055a29c">TypeValidForBooleanOperator</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#eafadd0241dcd2f613ac3d12acce3e88">TypeValidForArithmeticOperator</a> (<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> Type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#8b518f88cab465471ada4177c70fed93">ExtractTypeFromGenericExpr</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *Expr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#1864b442c83b686560aca2f79a535a36">ExtractTypeFromArrayRef</a> (<a class="el" href="class_c_array_ref_tree_node.html">CArrayRefTreeNode</a> *ArrRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#22070dba4508a48c75b035f386ec879c">ExtractTypeFromIdentifier</a> (<a class="el" href="class_c_identifier_tree_node.html">CIdentifierTreeNode</a> *Ident)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#a78b5e91d5644a40d18a93e4ca5ee790">ExtractTypeFromCallExpr</a> (<a class="el" href="class_c_call_expr_tree_node.html">CCallExprTreeNode</a> *CallExpr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#2a10a8e8f29ee96a406fd0aaeb49fb7f">ExtractTypeFromArithExpr</a> (<a class="el" href="class_c_arith_expr_tree_node.html">CArithExprTreeNode</a> *BinExpr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#061f1e95f8af5571e8c90fc1dc62b88d">TypeCheckParameter</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *Parm, <a class="el" href="class_c_tree_node.html">CTreeNode</a> *FnDecl, <a class="el" href="class_c_tree_node.html">CTreeNode</a> *CallExpr, unsigned int ParmId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#8d09f5387312b13c8e793275bdd7ffe4">AmbiguousDeclarationError</a> (<a class="el" href="struct_symbol__t.html">Symbol_t</a> *Sym)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#709627a8c6ee29c5d54f9a6f93a99c62">ValidateBooleanExprOperands</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *Expr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#e3c39b5a2891e088a91ba8e89141cd02">ValidateLogicalBlnExprOperands</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *Expr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#a1ca81a8f7f997a31b2396406af66511">ValidateRelationalBlnExprOperands</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *Expr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#dd6ad0fb90aa54f150742bbdcca1d3ce">AddFunctionParmsToSymbolTable</a> (<a class="el" href="class_c_tree_node.html">CTreeNode</a> *ParmList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#a2303af040545e53c34ce515286a6bde">IsFuncDeclAllowed</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#a0033ffe8a27213b4b6e2755fb0cb729">m_ParsingFuncDecl</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#853b181aabbd2346e285f83821705eba">m_FuncDeclAllowed</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#2e5ee52e7c9ecd4d4c5da48fb6e396c8">m_FoundNestedRetStmt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#0f68c55415ece314fdd54ca554a55dd9">m_CurrFuncDecl</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_lexical_scanner.html">CLexicalScanner</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#984eeb60cb67f24e96b2151ddc7a60d2">m_LexScanner</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_symbol_table.html">CSymbolTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#361142e74596ebf3bb5bb19c90aaf4bf">m_SymTable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_c_tree_node_factory.html">CTreeNodeFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#4090cb4b8c3aafd99dffd43d2a3021b1">m_ParseTreeBuilder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#469a96f91c2cbe8a06f547540b6edb3b">m_ErrorCount</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">map&lt; <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>, int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_parser.html#5f69a50ebca5765d4187913309a75bea">m_OpPrecs</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A recursive descent predictive parser for the langauge. This parses the entire file at once, performing the necessary syntactic and semantic analysis and building the parse tree as it goes. The error recovery technique employed is fairly basic in that it skips to the end of a statement if it's found to be invalid. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="f1b3d1f056e091028eee6915d8539349"></a><!-- doxytag: member="CParser::CParser" ref="f1b3d1f056e091028eee6915d8539349" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CParser::CParser           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a9e92d9d8b589f5e93aad4768293ae92"></a><!-- doxytag: member="CParser::~CParser" ref="a9e92d9d8b589f5e93aad4768293ae92" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CParser::~CParser           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f4ce3d1434b58134ec94e83795c204e7"></a><!-- doxytag: member="CParser::ParseSourceFile" ref="f4ce3d1434b58134ec94e83795c204e7" args="(const string &amp;InputFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseSourceFile           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>InputFile</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a single source file. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputFile</em>&nbsp;</td><td>Filename of the file to parse. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Parse tree for the file is successfull, NULL if any errors occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1cabdedd5fdc0c1d83168299c27a6b34"></a><!-- doxytag: member="CParser::IsType" ref="1cabdedd5fdc0c1d83168299c27a6b34" args="(TokenType Type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::IsType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the token represents a variable type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Type</em>&nbsp;</td><td>Token type to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the token represents a variable type, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="edf6b278729f314ba076cb8f4d6c556f"></a><!-- doxytag: member="CParser::IsLiteral" ref="edf6b278729f314ba076cb8f4d6c556f" args="(TokenType Type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::IsLiteral           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the token represents a literal token of any type - integer/float or string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Type</em>&nbsp;</td><td>Token type to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the type is a literal type, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f90fb427d9c479580276d7fe16d776ec"></a><!-- doxytag: member="CParser::IsArithmeticOperator" ref="f90fb427d9c479580276d7fe16d776ec" args="(TokenType Tok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::IsArithmeticOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Tok</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the token represents an arithmetic operator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tok</em>&nbsp;</td><td>Token type to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the token type is an arithmetic operator, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2dda8e89226ef7e1789514f6f4a9681d"></a><!-- doxytag: member="CParser::IsBooleanOperator" ref="2dda8e89226ef7e1789514f6f4a9681d" args="(TokenType Tok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::IsBooleanOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Tok</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like IsArithmeticOperator only this time for Boolean operators. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tok</em>&nbsp;</td><td>Token type to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the parameter is a Boolean operator, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b25cc5a4c1ef9e899ef285aed7b13b75"></a><!-- doxytag: member="CParser::IsLogicalOperator" ref="b25cc5a4c1ef9e899ef285aed7b13b75" args="(TokenType Tok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::IsLogicalOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Tok</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to see if a token represents a logical Boolean operator such as "and" or "or". <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tok</em>&nbsp;</td><td>The token type to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the token is a logical Boolean operator, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e58d729e2512194f87fa9b094039be8f"></a><!-- doxytag: member="CParser::IsRelationalOperator" ref="e58d729e2512194f87fa9b094039be8f" args="(TokenType Tok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::IsRelationalOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Tok</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like IsLogicalOperator only this time check for the relational Boolean operators "&lt;", "&lt;=", "&gt;" and "&gt;=". <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tok</em>&nbsp;</td><td>Token type to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the token is a relational Boolean operator, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="69a461f8b9d2fe3a94cbadbb4f5e6de2"></a><!-- doxytag: member="CParser::Error" ref="69a461f8b9d2fe3a94cbadbb4f5e6de2" args="(const string &amp;Msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::Error           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>Msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Issue an error message. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Msg</em>&nbsp;</td><td>Error message to emit. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ec78655a12ee9572bfa80bbfc9e51175"></a><!-- doxytag: member="CParser::Warning" ref="ec78655a12ee9572bfa80bbfc9e51175" args="(const string &amp;Msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::Warning           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>Msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Issue a warning. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Msg</em>&nbsp;</td><td>Warning message to emit. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2643514486cbfbe676ad2e0c3b25e9a6"></a><!-- doxytag: member="CParser::ExpectNextToken" ref="2643514486cbfbe676ad2e0c3b25e9a6" args="(const string &amp;Msg, const Token_t &amp;Tok, TokenType ExpType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::ExpectNextToken           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>Msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_token__t.html">Token_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>ExpType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that the next token scanned matches an expected type. If it doesn't an error is issued. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Msg</em>&nbsp;</td><td>Human readable string for the expected token type. This is used in the error message if the check fails. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Tok</em>&nbsp;</td><td>The next token returned from the lexical scanner to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ExpType</em>&nbsp;</td><td>The expected type of the token Tok. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the token matches the expected type, false if it doesn't. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c8245a4a442b916cfa5b9aac0c7bfcc7"></a><!-- doxytag: member="CParser::SkipToToken" ref="c8245a4a442b916cfa5b9aac0c7bfcc7" args="(TokenType Tok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::SkipToToken           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Tok</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keep consuming tokens until we find the end of the current statement. This is used during error recovery to skip over the remaining tokens of an invalid statement. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tok</em>&nbsp;</td><td>The token type to stop consuming tokens on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="250d6b93735cc2ac277e2650e5a63e86"></a><!-- doxytag: member="CParser::ParseVariableDeclaration" ref="250d6b93735cc2ac277e2650e5a63e86" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseVariableDeclaration           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variable declaration production rule. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the var decl. </dd></dl>

</div>
</div><p>
<a class="anchor" name="811433e48e5ff34bcded675ce04c112b"></a><!-- doxytag: member="CParser::ParseArrayDeclaration" ref="811433e48e5ff34bcded675ce04c112b" args="(CVarDeclTreeNode *Var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseArrayDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_var_decl_tree_node.html">CVarDeclTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array declaration production rule. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Var</em>&nbsp;</td><td>A VAR_DECL tree node we're wrapping in a new array decl. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the array declaration. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c270f9076fe2be9d05648c69d214c1d6"></a><!-- doxytag: member="CParser::ParseExpression" ref="c270f9076fe2be9d05648c69d214c1d6" args="(ExprContext Context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_parser_8h.html#54471c9fe8cb8379414c338753808e45">ExprContext</a>&nbsp;</td>
          <td class="paramname"> <em>Context</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a generic expression. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Context</em>&nbsp;</td><td>The context in which this expression is being parsed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node of either arith_expr or bln_expr type containing the expression. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a94b49b91faf58991d443830f4e3a13c"></a><!-- doxytag: member="CParser::ParseStatement" ref="a94b49b91faf58991d443830f4e3a13c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseStatement           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
High level statement parsing production rule. Looks at the next token and determines which production rule to apply next based upon it. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node representing the statement. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6bad239a9c86b8a6dd19d20fee25c160"></a><!-- doxytag: member="CParser::ParseIfStatement" ref="6bad239a9c86b8a6dd19d20fee25c160" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseIfStatement           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse an if statement including any statements which comprise the "then" and "else" arms of it. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node representing the new statement and it's body. </dd></dl>

</div>
</div><p>
<a class="anchor" name="09c90fc1cd34875e97229b51516b682d"></a><!-- doxytag: member="CParser::ParseAssignmentStatement" ref="09c90fc1cd34875e97229b51516b682d" args="(const string &amp;IdentifierName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseAssignmentStatement           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>IdentifierName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment statement production rule. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IdentifierName</em>&nbsp;</td><td>The name of the variable appearing on the LHS of the assignment. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node representing the assignment statement. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3544ff599051d1611688a3b8939da09d"></a><!-- doxytag: member="CParser::ParseWhileStatement" ref="3544ff599051d1611688a3b8939da09d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseWhileStatement           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
While statement production rule. Also parses the statements which make up the body and adds them to the new node returned. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the while statement. </dd></dl>

</div>
</div><p>
<a class="anchor" name="875dfb9fbc54fba3ebcb0cb4f3124f42"></a><!-- doxytag: member="CParser::ParseFunctionDecl" ref="875dfb9fbc54fba3ebcb0cb4f3124f42" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseFunctionDecl           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a function declaration, including the statements which make up it's body. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the function decl. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b6bf532d02d07e0378f0bcd9a1312e5"></a><!-- doxytag: member="CParser::ParseReturnStatement" ref="1b6bf532d02d07e0378f0bcd9a1312e5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseReturnStatement           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return statement production rule. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the statement. </dd></dl>

</div>
</div><p>
<a class="anchor" name="147afc14e002c04cfd48803e69325f12"></a><!-- doxytag: member="CParser::ParseFunctionCall" ref="147afc14e002c04cfd48803e69325f12" args="(const string &amp;FuncName, bool RequireSemiColon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseFunctionCall           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>FuncName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>RequireSemiColon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a call to a function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FuncName</em>&nbsp;</td><td>The name of the function that is being called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequireSemiColon</em>&nbsp;</td><td>True if we expect a semi-colon at the end which marks a call to a void function outside of any expression, otherwise we have something like "if(foo())" where we don't require a semi-colon after the function call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the function call. </dd></dl>

</div>
</div><p>
<a class="anchor" name="75b9f4903ac10249f0e213e3ade534dd"></a><!-- doxytag: member="CParser::ParseFuncCallOrAssignmentExpr" ref="75b9f4903ac10249f0e213e3ade534dd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseFuncCallOrAssignmentExpr           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse either a call to a function or an assignent expression. Once it's been determined what we have pass control over to the necessary production to handle the actual parsing. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the function call or assignment expression. </dd></dl>

</div>
</div><p>
<a class="anchor" name="909a4ef989d7cf778c83488798513973"></a><!-- doxytag: member="CParser::ParseFuncDeclParameterList" ref="909a4ef989d7cf778c83488798513973" args="(CTreeNode *ParmList, int &amp;NumParms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::ParseFuncDeclParameterList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ParmList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>NumParms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ParseFunctionDecl to handle the parsing of a function's declared parameters. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ParmList</em>&nbsp;</td><td>A parameter list tree node to add each parsed parameter to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumParms</em>&nbsp;</td><td>After this function returns, this will be set to the number of parsed parameters. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if parsing completed successfully, false on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="930a7ebfef02d003070100436055692e"></a><!-- doxytag: member="CParser::ValidateFuncReturnsInfo" ref="930a7ebfef02d003070100436055692e" args="(TokenType &amp;RetType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::ValidateFuncReturnsInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>RetType</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ParseFunctionDecl to handle the parsing of the "returns" clause of a function declaration. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RetType</em>&nbsp;</td><td>After this function returns, this will be set to the type that the function has been declared to return. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if parsing went ok, false on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3916ded31c4943bb76d8b3bfa035e01"></a><!-- doxytag: member="CParser::OperatorPrecedence" ref="f3916ded31c4943bb76d8b3bfa035e01" args="(TokenType Op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CParser::OperatorPrecedence           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Op</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the precedence of an operator. The actual precedences of each operator are initialised in the constructor. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Op</em>&nbsp;</td><td>The operator to get the precedence for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An integer value representing an operators precedence. </dd></dl>

</div>
</div><p>
<a class="anchor" name="985862bbdf56b9c478b6ff03b74c9eeb"></a><!-- doxytag: member="CParser::ReduceExpression" ref="985862bbdf56b9c478b6ff03b74c9eeb" args="(stack&lt; TokenType &gt; &amp;OpStack, stack&lt; CTreeNode * &gt; &amp;ValStack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::ReduceExpression           </td>
          <td>(</td>
          <td class="paramtype">stack&lt; <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>OpStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack&lt; <a class="el" href="class_c_tree_node.html">CTreeNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ValStack</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reduce the expression on top of the expression stacks. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OpStack</em>&nbsp;</td><td>Stack of arithmetic/Boolean operators. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ValStack</em>&nbsp;</td><td>Stack of expression terms representing the values. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if reduction succeeded, false on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a87085ab12a9675e5c860bcede9bd788"></a><!-- doxytag: member="CParser::DestroyExpressionStack" ref="a87085ab12a9675e5c860bcede9bd788" args="(stack&lt; CTreeNode * &gt; &amp;ValStack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::DestroyExpressionStack           </td>
          <td>(</td>
          <td class="paramtype">stack&lt; <a class="el" href="class_c_tree_node.html">CTreeNode</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ValStack</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the expression stack if we hit an error during parsing an expression. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ValStack</em>&nbsp;</td><td>Value stack to destroy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="581f8643dc39a254f3bf01c4cc00e908"></a><!-- doxytag: member="CParser::ParseExpressionTerm" ref="581f8643dc39a254f3bf01c4cc00e908" args="(stack&lt; TokenType &gt; &amp;OpStack, int &amp;ParenLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a> * CParser::ParseExpressionTerm           </td>
          <td>(</td>
          <td class="paramtype">stack&lt; <a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>OpStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>ParenLevel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper method for ParseExpression to parse and verify an single term. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OpStack</em>&nbsp;</td><td>Operator stack to add the next operator to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ParenLevel</em>&nbsp;</td><td>The current nesting level of parenthesis which we need to keep up to date when parsing a new expression term. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new tree node for the term. </dd></dl>

</div>
</div><p>
<a class="anchor" name="08b89b3f4ad4fe059043453a7e39a4f1"></a><!-- doxytag: member="CParser::TypeCheckExpression" ref="08b89b3f4ad4fe059043453a7e39a4f1" args="(CTreeNode *Expr, TokenType RequiredType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::TypeCheckExpression           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>RequiredType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform type checking on an expression to see if it's compatible with the requested type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Expr</em>&nbsp;</td><td>The expression to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequiredType</em>&nbsp;</td><td>The required type the expression must be compatible with. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="60003db442f5bd0a8c2a060615a44035"></a><!-- doxytag: member="CParser::TypeConvertsTo" ref="60003db442f5bd0a8c2a060615a44035" args="(TokenType Orig, TokenType To)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::TypeConvertsTo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>To</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See if a type can be converted to the requested type, this is only possible for implicit conversions between integral -&gt; floating point values as not information is lost in the process. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Orig</em>&nbsp;</td><td>The original type we're checking. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>To</em>&nbsp;</td><td>The type we're checking that Orig can be converted to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if Orig can be converted to To, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ee457c7626a1f8c6f3b4ef7fa020529a"></a><!-- doxytag: member="CParser::TypesCompatible" ref="ee457c7626a1f8c6f3b4ef7fa020529a" args="(TokenType TypeOne, TokenType TypeTwo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::TypesCompatible           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>TypeOne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>TypeTwo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if two types are compatible with each other. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TypeOne</em>&nbsp;</td><td>A _type value that a variable was declared with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TypeTwo</em>&nbsp;</td><td>A _literal or _type we're checking matches the declared type. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c208cea56aa2985ca1c3ba320055a29c"></a><!-- doxytag: member="CParser::TypeValidForBooleanOperator" ref="c208cea56aa2985ca1c3ba320055a29c" args="(TokenType Type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::TypeValidForBooleanOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if a given type is valid to appear either on side of a Boolean operator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Type</em>&nbsp;</td><td>The token type to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the token can appear with a Boolean expression, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eafadd0241dcd2f613ac3d12acce3e88"></a><!-- doxytag: member="CParser::TypeValidForArithmeticOperator" ref="eafadd0241dcd2f613ac3d12acce3e88" args="(TokenType Type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::TypeValidForArithmeticOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>&nbsp;</td>
          <td class="paramname"> <em>Type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like TypeValidForBooleanOperator only this time checking for arithmetic expressions. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_c_parser.html#c208cea56aa2985ca1c3ba320055a29c">TypeValidForBooleanOperator</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b518f88cab465471ada4177c70fed93"></a><!-- doxytag: member="CParser::ExtractTypeFromGenericExpr" ref="8b518f88cab465471ada4177c70fed93" args="(CTreeNode *Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> CParser::ExtractTypeFromGenericExpr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a tree , extract the underlying type of it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Expr</em>&nbsp;</td><td>The expression to extract the type from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of the expression. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1864b442c83b686560aca2f79a535a36"></a><!-- doxytag: member="CParser::ExtractTypeFromArrayRef" ref="1864b442c83b686560aca2f79a535a36" args="(CArrayRefTreeNode *ArrRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> CParser::ExtractTypeFromArrayRef           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_array_ref_tree_node.html">CArrayRefTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ArrRef</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ExtractTypeFromGenericExpr to handle array references. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ArrRef</em>&nbsp;</td><td>Array reference tree node to extract the type from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of the array being referenced. </dd></dl>

</div>
</div><p>
<a class="anchor" name="22070dba4508a48c75b035f386ec879c"></a><!-- doxytag: member="CParser::ExtractTypeFromIdentifier" ref="22070dba4508a48c75b035f386ec879c" args="(CIdentifierTreeNode *Ident)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> CParser::ExtractTypeFromIdentifier           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_identifier_tree_node.html">CIdentifierTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Ident</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ExtractTypeFromGenericExpr to handle identifiers which could refer to functions, variables or parameters. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Ident</em>&nbsp;</td><td>Identifier to get the type for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of the decl the identifier refers to. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a78b5e91d5644a40d18a93e4ca5ee790"></a><!-- doxytag: member="CParser::ExtractTypeFromCallExpr" ref="a78b5e91d5644a40d18a93e4ca5ee790" args="(CCallExprTreeNode *CallExpr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> CParser::ExtractTypeFromCallExpr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_call_expr_tree_node.html">CCallExprTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>CallExpr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ExtractTypeFromGenericExpr to handle call_exprs. The type of call_exprs is the return type of the function being called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallExpr</em>&nbsp;</td><td>Function call expr we're getting the type of. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The return type of the function being called. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a10a8e8f29ee96a406fd0aaeb49fb7f"></a><!-- doxytag: member="CParser::ExtractTypeFromArithExpr" ref="2a10a8e8f29ee96a406fd0aaeb49fb7f" args="(CArithExprTreeNode *BinExpr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a> CParser::ExtractTypeFromArithExpr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_arith_expr_tree_node.html">CArithExprTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>BinExpr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ExtractTypeFromGenericExpr to handle arithmetic expressions. If the operator used is a Boolean operator, the whole expression is of type Boolean otherwise the type of an arithmetic expression is defined to be of the type appearing on the LHS. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BinExpr</em>&nbsp;</td><td>Expr to determine the type of. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of the expression. </dd></dl>

</div>
</div><p>
<a class="anchor" name="061f1e95f8af5571e8c90fc1dc62b88d"></a><!-- doxytag: member="CParser::TypeCheckParameter" ref="061f1e95f8af5571e8c90fc1dc62b88d" args="(CTreeNode *Parm, CTreeNode *FnDecl, CTreeNode *CallExpr, unsigned int ParmId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::TypeCheckParameter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Parm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>FnDecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>CallExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>ParmId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Typechecking of parameters appears in three locations, the code for which is identical in both cases so it's extracted to a common method here that gets used instead. If the check fails both Parm and CallExpr will be destroyed and the token stream skipped to the closing semi-colon. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Parm</em>&nbsp;</td><td>The parameter decl being checked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FnDecl</em>&nbsp;</td><td>Function the parameter belongs to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallExpr</em>&nbsp;</td><td>Function call expression being processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ParmId</em>&nbsp;</td><td>The parameter's index in the function's parameter list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if type checking succeeded, false on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d09f5387312b13c8e793275bdd7ffe4"></a><!-- doxytag: member="CParser::AmbiguousDeclarationError" ref="8d09f5387312b13c8e793275bdd7ffe4" args="(Symbol_t *Sym)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CParser::AmbiguousDeclarationError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_symbol__t.html">Symbol_t</a> *&nbsp;</td>
          <td class="paramname"> <em>Sym</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Give an error about an ambiguous declaration. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Sym</em>&nbsp;</td><td>The ambiguous symbol. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="709627a8c6ee29c5d54f9a6f93a99c62"></a><!-- doxytag: member="CParser::ValidateBooleanExprOperands" ref="709627a8c6ee29c5d54f9a6f93a99c62" args="(CTreeNode *Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::ValidateBooleanExprOperands           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform semantic checking on the operands to a Boolean expr. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Expr</em>&nbsp;</td><td>The expression being checked. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the expression is semantically valid, false if it's not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3c39b5a2891e088a91ba8e89141cd02"></a><!-- doxytag: member="CParser::ValidateLogicalBlnExprOperands" ref="e3c39b5a2891e088a91ba8e89141cd02" args="(CTreeNode *Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::ValidateLogicalBlnExprOperands           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ValidateBooleanExprOperands. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_c_parser.html#709627a8c6ee29c5d54f9a6f93a99c62">ValidateBooleanExprOperands</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a1ca81a8f7f997a31b2396406af66511"></a><!-- doxytag: member="CParser::ValidateRelationalBlnExprOperands" ref="a1ca81a8f7f997a31b2396406af66511" args="(CTreeNode *Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::ValidateRelationalBlnExprOperands           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>Expr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ValidateBooleanExprOperands. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_c_parser.html#709627a8c6ee29c5d54f9a6f93a99c62">ValidateBooleanExprOperands</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd6ad0fb90aa54f150742bbdcca1d3ce"></a><!-- doxytag: member="CParser::AddFunctionParmsToSymbolTable" ref="dd6ad0fb90aa54f150742bbdcca1d3ce" args="(CTreeNode *ParmList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::AddFunctionParmsToSymbolTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_tree_node.html">CTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>ParmList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subroutine of ParseFunctionDecl to add any declared parameters to the current scope, checking for ambiguities along the way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ParmList</em>&nbsp;</td><td>List of declared parameters for the function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if no anbiguities were found, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2303af040545e53c34ce515286a6bde"></a><!-- doxytag: member="CParser::IsFuncDeclAllowed" ref="a2303af040545e53c34ce515286a6bde" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CParser::IsFuncDeclAllowed           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if a function declaration is allowed at the point when this is called. If one isn't allowed, issues an error message and skips any tokens until the closing "end_function" is found. <dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a function declaration is allowed at the current point, otherwise false. </dd></dl>

</div>
</div><p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="a0033ffe8a27213b4b6e2755fb0cb729"></a><!-- doxytag: member="CParser::m_ParsingFuncDecl" ref="a0033ffe8a27213b4b6e2755fb0cb729" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_parser.html#a0033ffe8a27213b4b6e2755fb0cb729">CParser::m_ParsingFuncDecl</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if we're in the middle of parsing a function decl 
</div>
</div><p>
<a class="anchor" name="853b181aabbd2346e285f83821705eba"></a><!-- doxytag: member="CParser::m_FuncDeclAllowed" ref="853b181aabbd2346e285f83821705eba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_parser.html#853b181aabbd2346e285f83821705eba">CParser::m_FuncDeclAllowed</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if a function declaration is allowed to appear here 
</div>
</div><p>
<a class="anchor" name="2e5ee52e7c9ecd4d4c5da48fb6e396c8"></a><!-- doxytag: member="CParser::m_FoundNestedRetStmt" ref="2e5ee52e7c9ecd4d4c5da48fb6e396c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_c_parser.html#2e5ee52e7c9ecd4d4c5da48fb6e396c8">CParser::m_FoundNestedRetStmt</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if we've found a return stmt inside the current function, we use this because otherwise we'd miss return statements which are 'hidden' inside if/while statements. 
</div>
</div><p>
<a class="anchor" name="0f68c55415ece314fdd54ca554a55dd9"></a><!-- doxytag: member="CParser::m_CurrFuncDecl" ref="0f68c55415ece314fdd54ca554a55dd9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node.html">CTreeNode</a>* <a class="el" href="class_c_parser.html#0f68c55415ece314fdd54ca554a55dd9">CParser::m_CurrFuncDecl</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function we're currently parsing 
</div>
</div><p>
<a class="anchor" name="984eeb60cb67f24e96b2151ddc7a60d2"></a><!-- doxytag: member="CParser::m_LexScanner" ref="984eeb60cb67f24e96b2151ddc7a60d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_lexical_scanner.html">CLexicalScanner</a> <a class="el" href="class_c_parser.html#984eeb60cb67f24e96b2151ddc7a60d2">CParser::m_LexScanner</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The scanner which provides us with tokens. 
</div>
</div><p>
<a class="anchor" name="361142e74596ebf3bb5bb19c90aaf4bf"></a><!-- doxytag: member="CParser::m_SymTable" ref="361142e74596ebf3bb5bb19c90aaf4bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_symbol_table.html">CSymbolTable</a>* <a class="el" href="class_c_parser.html#361142e74596ebf3bb5bb19c90aaf4bf">CParser::m_SymTable</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Local copy of the symbol table used during parsing 
</div>
</div><p>
<a class="anchor" name="4090cb4b8c3aafd99dffd43d2a3021b1"></a><!-- doxytag: member="CParser::m_ParseTreeBuilder" ref="4090cb4b8c3aafd99dffd43d2a3021b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_tree_node_factory.html">CTreeNodeFactory</a>* <a class="el" href="class_c_parser.html#4090cb4b8c3aafd99dffd43d2a3021b1">CParser::m_ParseTreeBuilder</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tree node factory to build the various tree nodes. 
</div>
</div><p>
<a class="anchor" name="469a96f91c2cbe8a06f547540b6edb3b"></a><!-- doxytag: member="CParser::m_ErrorCount" ref="469a96f91c2cbe8a06f547540b6edb3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_c_parser.html#469a96f91c2cbe8a06f547540b6edb3b">CParser::m_ErrorCount</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of errors which occurred during parsing 
</div>
</div><p>
<a class="anchor" name="5f69a50ebca5765d4187913309a75bea"></a><!-- doxytag: member="CParser::m_OpPrecs" ref="5f69a50ebca5765d4187913309a75bea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;<a class="el" href="_token_types_8h.html#a520fbf142ba1e7e659590c07da31921">TokenType</a>, int&gt; <a class="el" href="class_c_parser.html#5f69a50ebca5765d4187913309a75bea">CParser::m_OpPrecs</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A hash table of token strings and their equivalent operator precedence used for fast look up during expression parsing. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_c_parser_8h.html">CParser.h</a><li><a class="el" href="_c_parser_8cpp.html">CParser.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed May 16 12:56:54 2007 for CP3343 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
